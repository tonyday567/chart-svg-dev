
* chart-svg-dev

[[https://hackage.haskell.org/package/chart-svg-dev][https://img.shields.io/hackage/v/chart-svg-dev.svg]]
[[https://github.com/tonyday567/chart-svg-dev/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/chart-svg-dev/workflows/haskell-ci/badge.svg]]

~chart-svg-dev~ is a development environment for chart-svg.

* Imports

#+begin_src haskell :results output
:r
:set prompt "> "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -XTupleSections
import Lib
import Prelude
import Control.Category ((>>>))
import Data.Function
import Data.Maybe
import Data.Bool
import Faker.Lorem
import Chart
import Prettychart
import Chart.Examples
import Optics.Core
import Data.ByteString.Char8 qualified as C
import Data.Text qualified as T
import Control.Monad
import NumHask.Prelude qualified as NH
import Data.Functor.Identity
import Data.Bifunctor
(display, quit) <- startChartServer (Just "chart-svg-dev")
#+end_src

#+RESULTS:

#+begin_src haskell :results output
display unitExample
#+end_src

#+RESULTS:
: True

** chart-svg examples

#+begin_src haskell :results output
writeAllExamples
#+end_src

#+RESULTS:
: ok

#+begin_src haskell :results output
display $ pathExample & #markupOptions % #chartAspect .~ ChartAspect
#+end_src

#+RESULTS:
: True


* ToDo ScaleP
** ToDo generalise ScaleP
** ToDo Add chartData for all chart types
** trial chart

#+begin_src haskell :results output
mo = defaultMarkupOptions & #chartAspect .~ ChartAspect & #markupHeight .~ Just 300
gs = defaultGlyphStyle & #scaleGlyph .~ ScalePArea
ho = defaultHudOptions & #axes %~ fmap (second (#ticks % #gtick %~ fmap (first (#scaleGlyph .~ ScalePArea))))
r2 = mempty & #charts .~ unnamed [GlyphChart gs $ uncurry Point <$> runG (rvsp 4 (-0.5))] & #hudOptions .~ ho :: ChartOptions
display $ mempty & #markupOptions .~ mo & #charts .~ stack 3 0.1 (replicate 9 (toCT r2))
-- display r2

#+end_src

#+RESULTS:
: True

Different glyphtick

#+begin_src haskell :results output
sh = TriangleGlyph (Point 0.0 (0.5 * sqrt 2)) (Point (-cos (pi / 3)) (-sin (pi / 3) / 2)) (Point (cos (pi / 3)) (-sin (pi / 3) / 2))
mo = defaultMarkupOptions & #chartAspect .~ FixedAspect 2 & #markupHeight .~ Just 300
gs = defaultGlyphStyle & #scaleGlyph .~ ScalePArea
ho = defaultHudOptions & #axes %~ fmap (second (#ticks % #gtick %~ fmap (first (#scaleGlyph .~ ScalePArea >>> #shape .~ sh))))
r2 = mempty & #charts .~ unnamed [GlyphChart gs $ uncurry Point <$> runG (rvsp 4 (-0.5))] & #hudOptions .~ ho :: ChartOptions
-- display $ mempty & #markupOptions .~ mo & #charts .~ stack 3 0.1 (replicate 9 (toCT r2))
-- display r2
display $ mempty & #markupOptions .~ mo & #charts .~ hori 0.1 (replicate 3 (toCT r2))

#+end_src

#+RESULTS:
: True

Other chart types

#+begin_src haskell :results output
mo = defaultMarkupOptions & #chartAspect .~ FixedAspect 1.5 & #markupHeight .~ Just 300
-- display $ pathExample & #markupOptions .~ mo
display $ mempty & #markupOptions .~ mo & #charts .~ stack 5 0.1 (replicate 25 (toCT pathExample))

#+end_src

#+RESULTS:
: True


** Next style unification

similar to https://hackage.haskell.org/package/reanimate-svg-0.9.3.1/docs/Graphics-SvgTree-Types.html#v:drawAttributes

#+begin_src haskell :results output
data RectStyle = RectStyle
  { borderSize :: Double,
    borderColor :: Colour,
    color :: Colour,
    scaleRect :: ScaleP
  }
data TextStyle = TextStyle
  { size :: Double,
    color :: Colour,
    anchor :: Anchor,
    hsize :: Double,
    vsize :: Double,
    vshift :: Double,
    rotation :: Maybe Double,
    scaleText :: ScaleP,
    escapeText :: EscapeText,
    frame :: Maybe RectStyle
  }
data GlyphStyle = GlyphStyle
  { -- | glyph radius
    size :: Double,
    -- | fill color
    color :: Colour,
    -- | stroke color
    borderColor :: Colour,
    -- | stroke width (adds a bit to the bounding box)
    borderSize :: Double,
    shape :: GlyphShape,
    rotation :: Maybe Double,
    translate :: Maybe (Point Double),
    scaleGlyph :: ScaleP
  }
data LineStyle = LineStyle
  { size :: Double,
    color :: Colour,
    linecap :: Maybe LineCap,
    linejoin :: Maybe LineJoin,
    dasharray :: Maybe [Double],
    dashoffset :: Maybe Double,
    scaleLine :: ScaleP
  }
data PathStyle = PathStyle
  { borderSize :: Double,
    borderColor :: Colour,
    color :: Colour,
    scalePath' :: ScaleP
  }
#+end_src

linecap
linejoin
dasharray
dashoffset

scaleText
escapeText
frame

* Color a frame lens

  #+begin_src haskell :results output
display (glyphsExample & #markupOptions % #chartAspect .~ FixedAspect 3 & traverseOf (#charts % charts') (Identity . fmap (\x -> x & set (glyphStyle' %? #scaleGlyph) ScalePArea)) & runIdentity & over (#hudOptions % #frames) (<>[(30, defaultFrameOptions & #frame %? #color .~ grey 0.5 0.4)]))
  #+end_src


#+RESULTS:
: True

* ToDo multiple axes on one side

- [ ] better axis placement when multiple axis marks on one side


#+begin_src haskell :results output
disp $ unitExample & #hudOptions %~ colourHudOptions (set opac' 0.3) & #hudOptions %~ (<> (mempty & #axes .~ [(Priority 20, defaultAxisOptions)]))
#+end_src

#+RESULTS:
: True

* Text chart (re)callibration

- more precise callibration of text scaling

*** exampleTextChart

#+begin_src haskell :results output
t1 <- exampleTextChart 4 6
display $ (mempty & #charts .~ unnamed t1 :: ChartOptions)
t1
#+end_src

Adding a frame

#+begin_src haskell :results output
display $ (mempty & #charts .~ unnamed t1 & #hudOptions % #frames .~ [(3,FrameOptions (Just (defaultRectStyle & #color .~ set opac' 0.05 (palette1 4))) 0)])
#+end_src

#+RESULTS:
: True

Adding a point

#+begin_src haskell :results output
ps = (\x -> GlyphChart defaultGlyphStyle [Point 0 x]) <$>  [0..3]
display $ (mempty & #charts .~ unnamed (t1 <> ps))
#+end_src

#+RESULTS:
: True

*** scaling decomposition of exampleTextChart

**** ChartAspect

No scaling anywhere looks ok.

#+begin_src haskell :results output
t1 <- exampleTextChart' 3 3 (defaultTextStyle & #frame .~ Just defaultRectStyle & #hsize .~ 0.65 & #vshift .~ (-0.3))
display (mempty & #charts .~ unnamed t1 & #hudOptions % #chartAspect .~ ChartAspect :: ChartOptions)
#+end_src

#+RESULTS:
: True

#+begin_src haskell :results output
fromIntegral (length "incidunt et consequatur") * 0.65 * 0.12
#+end_src

#+RESULTS:
: 1.794

Width is hsize * size * num characters plus a bit (???) (+/-0.0006)

#+begin_src haskell :results output
:set -Wno-incomplete-uni-patterns
(Just r@(Rect x z y w)) = styleBoxes t1
r
#+end_src

#+RESULTS:
: Rect -6.0e-4 1.7946 -3.0600000000000006e-2 2.1026

height is stylebox dimensions * width of 300

#+begin_src haskell :results output
(z-x)/(w-y)*300
#+end_src

#+RESULTS:
: 252.46577911119442

Add a frame gives same dimensions:

#+begin_src haskell :results output
chartFrame = #hudOptions % #frames .~ [(3,FrameOptions (Just (defaultRectStyle & #borderSize .~ 0 & #color .~ set opac' 0.05 (palette1 4))) 0)]
display (mempty & #charts .~ unnamed t1 & chartFrame & #hudOptions % #chartAspect .~ ChartAspect :: ChartOptions)
#+end_src

#+RESULTS:
: True

**** FixedAspect
#+begin_src haskell :results output
chartFrame = #hudOptions % #frames .~ [(3,FrameOptions (Just (defaultRectStyle & #color .~ set opac' 0.05 (palette1 4))) 0)]
t2 <- exampleTextChart' 3 3 (defaultTextStyle & #frame .~ Just defaultRectStyle & #hsize .~ 0.65 & #scalex .~ ScaleX)
display $ (mempty & #charts .~ unnamed t2 :: ChartOptions)
#+end_src

#+RESULTS:
: True

#+begin_src haskell :results output
chartFrame = #hudOptions % #frames .~ [(3,FrameOptions (Just (defaultRectStyle & #color .~ set opac' 0.05 (palette1 4))) 0)]
t2 <- exampleTextChart' 3 3 (defaultTextStyle & #frame .~ Just defaultRectStyle & #hsize .~ 0.65)
display $ (mempty & #charts .~ unnamed t2 :: ChartOptions)
#+end_src

#+RESULTS:
: True

#+begin_src haskell :results output
fromIntegral (length "dignissimos in distinctio") *0.65 * 0.12
:set -Wno-incomplete-uni-patterns
(Just r@(Rect x z y w)) = styleBoxes t2
r
#+end_src

#+RESULTS:
: 1.95
: Rect -6.0e-4 1.9506 -3.660000000000001e-2 2.0966

x scaling for text size

#+begin_src haskell :results output
1.5 / (z-x) * 0.12
#+end_src

#+RESULTS:
: 9.225092250922509e-2

**** deconstruction of scaling functions

addHud

#+begin_src haskell :results output
view styleBox' $ addHud mempty (unnamed t2)
#+end_src

#+RESULTS:
: Just Rect -0.75 0.75 -0.5000000000000001 0.5

#+begin_src haskell :results output
1.5 / (1.9506 + 0.0006) * 0.12
#+end_src

#+RESULTS:
: 9.225092250922509e-2

initialCanvas

#+begin_src haskell :results output
ic = initialCanvas (view #chartAspect (mempty::HudOptions)) (unnamed t2)
ic
#+end_src

#+RESULTS:
: Rect -0.75 0.75 -0.5 0.5

runHudWith

#+begin_src haskell :results output
import Data.Bifunctor
(hs, db') = toHuds mempty $ maybe one padSingletons (view box' (unnamed t2))
(view box' (unnamed t2))
runHudWith ic db' hs (unnamed t2)

length hs
#+end_src

#+RESULTS:
: Just Rect 0.0 0.0 0.0 2.0
: ChartTree {tree = Node {rootLabel = (Nothing,[]), subForest = [Node {rootLabel = (Just "chart",[]), subForest = [Node {rootLabel = (Nothing,[TextChart (TextStyle {size = 9.225092250922509e-2, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("veritatis iure natus",Point -0.7495387453874539 -0.4718634686346864)],TextChart (TextStyle {size = 9.225092250922509e-2, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("dignissimos in distinctio",Point -0.7495387453874539 -2.3062730627306294e-2)],TextChart (TextStyle {size = 9.225092250922509e-2, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("ea et aut",Point -0.7495387453874539 0.42573800738007384)]]), subForest = []}]},Node {rootLabel = (Just "hud",[]), subForest = [Node {rootLabel = (Nothing,[]), subForest = []}]}]}}
: > 1

projectWith

#+begin_src haskell :results output
ic
db'
projectWith ic db' <$> t1
#+end_src

#+RESULTS:
: Rect -0.75 0.75 -0.5 0.5
: Rect -0.5 0.5 0.0 2.0
: [TextChart (TextStyle {size = 0.18, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.3, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("delectus porro quia",Point 0.0 -0.5)],TextChart (TextStyle {size = 0.18, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.3, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("molestiae molestiae voluptatibus",Point 0.0 0.0)],TextChart (TextStyle {size = 0.18, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.65, vsize = 1.1, vshift = -0.3, rotation = Nothing, scalex = ScaleX, frame = Just (RectStyle {borderSize = 1.0e-2, borderColor = Colour 0.02 0.29 0.48 1.00, color = Colour 0.02 0.73 0.80 0.10})}) [("aut ut eligendi",Point 0.0 0.5)]]

applyChartAspect

#+begin_src haskell :results output
import Control.Monad.State.Lazy
flip execState (HudChart (unnamed t1 & over chart' (projectWith ic db')) mempty db') (applyChartAspect (ChartAspect))
#+end_src

#+RESULTS:
: HudChart {chart = ChartTree {tree = Node {rootLabel = (Nothing,[TextChart (TextStyle {size = 0.18, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing}) [("doloremque",Point 0.0 -0.5)],TextChart (TextStyle {size = 0.18, color = Colour 0.05 0.05 0.05 1.00, anchor = AnchorStart, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing}) [("reiciendis",Point 0.0 0.5)]]), subForest = []}}, hud = ChartTree {tree = Node {rootLabel = (Nothing,[]), subForest = []}}, dataBox = Rect -0.5 0.5 0.0 1.0}

#+begin_src haskell :results output
hc = (HudChart (unnamed t1 & over chart' (projectWith ic db')) mempty db')
hc' = set hudBox' (getHudBox (FixedAspect 1.5) hc) hc
#+end_src

#+RESULTS:

#+begin_src haskell :results output
import NumHask.Prelude qualified as NH
:set -Wno-incomplete-uni-patterns
(Just hsb) = view hudStyleBox' hc
(Just hb) = view hudBox' hc
(Just rebox') = (getHudBox (FixedAspect 1.5) hc)
r' = rebox' NH.- (hsb NH.- hb)
:t styleBoxes $ projectWith r' hb <$> t1
r'
hb
#+end_src

#+RESULTS:
: styleBoxes $ projectWith r' hb <$
: t1 :: Maybe (Rect Double)
: Rect -0.75 -6.000000000000005e-2 -0.44599999999999995 0.356
: Rect 0.0 0.0 -0.5 0.5

#+begin_src haskell :results output
view hudStyleBox' hc
view hudStyleBox' hc'
view hudBox' hc'
#+end_src

#+RESULTS:
: Just Rect 0.0 0.81 -0.554 0.644
: Just Rect 0.0 0.81 -0.49999999999999994 0.5
: Just Rect 0.0 0.0 -0.44599999999999995 0.356
**** rectangle

A rectangle based on the initial style box of text is not going to track scaling of text size in any way.

#+begin_src haskell :results output
r1 = RectChart defaultRectStyle [fromMaybe undefined $ styleBoxes t1]
#+end_src

#+RESULTS:

**** point

#+begin_src haskell :results output
rDefault = RectChart defaultRectStyle [one]
ps = (\x -> GlyphChart defaultGlyphStyle [Point 0 x]) <$>  [0..2]
r1 = RectChart defaultRectStyle [fromMaybe undefined $ styleBoxes t1]
display $ mempty & #charts .~ unnamed (t1 <> ps) & #hudOptions % #frames .~ [(3,FrameOptions (Just (defaultRectStyle & #color .~ set opac' 0.05 (palette1 4))) 0)]
#+end_src

#+RESULTS:
: True
