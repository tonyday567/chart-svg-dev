
* chart-svg-dev

[[https://hackage.haskell.org/package/chart-svg-dev][https://img.shields.io/hackage/v/chart-svg-dev.svg]]
[[https://github.com/tonyday567/chart-svg-dev/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/chart-svg-dev/workflows/haskell-ci/badge.svg]]

~chart-svg-dev~ is a development environment for chart-svg.

* Imports

#+begin_src haskell :results output
:r
-- :set prompt "> "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -XTupleSections
import Lib
import Prelude
import Control.Category ((>>>))
import Data.Function
import Data.Maybe
import Data.Bool
import Faker.Lorem
import Chart
import Prettychart
import Chart.Examples
import Optics.Core
import Data.ByteString.Char8 qualified as C
import Data.Text qualified as T
import Control.Monad
import NumHask.Prelude qualified as NH
import Data.Functor.Identity
import Data.Bifunctor
import Prettyprinter
import Text.Pretty.Simple
import MarkupParse
(display, quit) <- startChartServer (Just "chart-svg-dev")
#+end_src

#+RESULTS:

** chart-svg examples

#+begin_src haskell :results output
writeAllExamples
#+end_src

#+RESULTS:
: ok

* Next chart-svg mega cleanup checklist

- [ ] [[*small data range bug][small data range bug]]
- [ ] audit ScaleP usage
- [ ] using ScalePX and Y on glyph ticks
- [ ] [[*reduce this tick gaps callibration][reduce this tick gaps callibration]]
- [ ] [[*lineExample][lineExample]]
- [ ] [[*Exact reproduction of proportionate scaling][Exact reproduction of proportionate scaling]]
- [ ] [[*text chart scaling][text chart scaling]]
- [ ] [[*chart-svg-dev: styleBox' versus styleBoxN' versus projectChartTree][chart-svg-dev: styleBox' versus styleBoxN' versus projectChartTree]]
- [ ] Revisit anal [[file:~/haskell/anal/readme.org::*all in one][all in one]]
- [ ] code ToDos
- [ ] rebuild surface legend chart
- [ ] move GlyphShape back to Style
- [ ] switch to svg names for attributes
- [ ] palette1 ==> palette
- [ ] #charts -> #chartTree
- [ ] rename initialCanvas
- [ ] fix scalePath'
- [ ] fix Rect show instance
- [ ] Fix up Ticks
  - prisms
  - record types inside the sum types
- [ ] better names for tick elements
- [ ] remove placeText
- [ ] simplify :: ChartTree -> ChartTree
  descend, combining unnamed nodes
- [ ] #hud --> #hudChart
- [ ] shift from huds making ChartTrees to [Charts]
- [ ] remove canvasStyleBox'
- [ ] paint order
  [[https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order][paint-order - SVG: Scalable Vector Graphics | MDN]]
- [ ] check examples
- [ ] check initialCanvas usage
- [ ] check applyChartAspect usage
- [ ] map runHud, addHud, toHuds
- [ ] map HudChart usage
- [ ] work upwards from mempty
- [ ] default number of ticks to 5
- [ ] smaller default text tick
- [ ] smaller default text size
- [ ] no border to legend

* lineExample

- [ ] y axis glyph tick buffer
- [ ] y axis text tick buffer
- [ ] why has unit tick extension happened?

#+begin_src haskell :results output
co = lineExample
display unitExample
#+end_src

#+RESULTS:

* reduce this tick gaps callibration

This example looks accurate.

#+begin_src haskell :results output
r1 = fmap (*1) (Rect 0 1 0 1)
bar' = (AxisBar (border 0.001 (grey 0.3 1)) 0.05 0 0)
rs1 = border 0.001 (grey 0.3 1)
tt = (defaultTextTick,0)
gt = defaultGlyphTick & set #borderSize 0.001 & set #color (grey 0.3 1) & set #size 0.1
g = TriangleGlyph (Point 0 1) (Point (-0.5) 0) (Point 0.5 0)
display $ mempty & set #charts (unnamed [blankChart1 r1]) & set (#markupOptions % #chartAspect) UnscaledAspect & set (#markupOptions % #markupHeight) (Just 500) & set (#hudOptions % #axes) ([(5,defaultYAxisOptions & set #place PlaceLeft), (5,defaultXAxisOptions & set #place PlaceBottom)]) & set (#hudOptions % #axes % each % _2 % #ticks % #ltick) Nothing & set (#hudOptions % #axes % each % _2 % #bar) (Just bar') & set (#hudOptions % #axes % each % _2 % #ticks % #ttick) (Just tt) & set (#hudOptions % #axes % each % _2 % #ticks % #ttick %? _2) 0 & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _1) gt & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _3) 0.0 & set (#hudOptions % #axes % each % _2 % #ticks % #ttick %? _1 % #frame) (Just (border 0.005 black)) & set (#hudOptions % #frames) [(1,defaultFrameOptions & set #frame (Just rs1))]
#+end_src

* Exact reproduction of proportionate scaling

- [ ] check if this proportionate scaling is exact

Scaling of style elements is proportional to the ratio of areas of the before and after rectangle. This means that individual elements do not scale to the exact proportions of the overall projections.

#+begin_src haskell :results output
r1 = fmap (*1) (Rect 0 1 0 1)
bar' = (AxisBar (blob (grey 0.3 0.1)) 0.05 0 0)
bar'' = (AxisBar (border 0.001 (grey 0.3 1)) 0.05 0 0)
rs1 = blob (grey 0.3 0.3)
tt = defaultTextTick & set #scaleP ScalePArea & set #frame (Just rs1)
gt = defaultGlyphTick & set #scaleP ScalePArea & set #borderSize 0 & set #color (grey 0.3 0.1) & set #size 0.1
gt' = (Just (gt, SquareGlyph, 0))
g = TriangleGlyph (Point 0 1) (Point (-0.5) 0) (Point 0.5 0)
fa = ((0.536 + (0.536))/ (0.5 + 0.545))
co = (mempty :: ChartOptions) & set #charts (unnamed [blankChart1 r1]) & set (#markupOptions % #chartAspect) (FixedAspect fa) & set (#hudOptions % #frames) [(1,defaultFrameOptions & set #frame (Just rs1))] & set (#hudOptions % #axes) ([(5,defaultXAxisOptions & set #place PlaceBottom), (6,defaultXAxisOptions & set #place PlaceBottom)]) & set (#hudOptions % #axes % each % _2 % #ticks % #ltick) Nothing & set (#hudOptions % #axes % each % _2 % #bar) (Just bar') & set (#hudOptions % #axes % each % _2 % #ticks % #gtick) Nothing & set (#hudOptions % #axes % each % _2 % #ticks % #ttick) (Just (tt,0)) & set (#hudOptions % #axes % each % _2 % #ticks % #style) (TickRound (FormatN FSCommaPrec (Just 1) 2 True True) 2 NoTickExtend)
display co
#+end_src

#+RESULTS:

*** Scaled boxes

    #+begin_src haskell :results output
asp = FixedAspect 1
csAndHud = addHud (view (#markupOptions % #chartAspect) co) (view #hudOptions co) (view #charts co)
viewbox = initialCanvas asp csAndHud
finalCT = projectChartTreeN (view (#markupOptions % #repeatAspect) co) viewbox csAndHud
sbox <$> (mconcat $ toListOf charts' finalCT)
view styleBox' finalCT
view styleBox' csAndHud
    #+end_src

#+RESULTS:
: [Just Rect -0.466413194519965 0.466413194519965 -0.45721626154242156 0.5,Just Rect -0.466413194519965 0.466413194519965 -0.45721626154242156 0.5,Just Rect -0.5000000000000002 0.5000000000000002 -0.49999999999999994 -0.45894945996884584]
: Just Rect -0.5000000000000002 0.5000000000000002 -0.49999999999999994 0.5
: Just Rect -0.5489186602870815 0.5489186602870815 -0.545 0.5

#+begin_src haskell :results output

(0.536 + (0.536))/ (0.5 + 0.545)
#+end_src

#+RESULTS:
: 1.0258373205741629

An exact projection would be:

#+begin_src haskell :results output
p0 = fromMaybe undefined (view styleBox' csAndHud)
p0
c0 = mconcat $ toListOf charts' csAndHud
p' = projectRect p0 (aspect 1) :: Rect Double -> Rect Double
fmap p' . sbox <$> c0
#+end_src

#+RESULTS:
: Rect -0.5489186602870815 0.5489186602870815 -0.545 0.5
: [Just Rect -0.4672082563369478 0.46720825633694774 -0.45693779904306214 0.5,Just Rect -0.4672082563369478 0.46720825633694774 -0.45693779904306214 0.5,Just Rect -0.5 0.5 -0.5 -0.45789473684210524]

#+begin_src haskell :results output
ct' = projectChartTree one csAndHud
view styleBox' ct'
#+end_src

#+RESULTS:
: Just Rect -0.5008187862982173 0.5008187862982173 -0.4997202563985731 0.5

* small data range bug

- [ ] gaps are not scaling
- [ ] bordersize of a vlineglyph
- [ ] scalep usage in small data ranges
- [ ] Is NoScaleP the defaultHudOptions
- [ ] toggle to switch to ScalePArea when the hud is forgotten
- [ ] vertical axis tick marks are slightly too left, hori ticks a bit too high, obvious on FixedAspect 2, hudOptionsExample

#+begin_src haskell :results output
bar' = (AxisBar (blob (grey 0.3 0.1)) 0.005 0.01 0)
co = unitExample & set (#hudOptions % #axes % each % _2 % #bar) (Just bar') & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _3) 0 & set (#hudOptions % #axes % each % _2 % #ticks % #ttick %? _2) 0.0 & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _1 % #scaleP) NoScaleP & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _1 % #borderSize) 0.005 & set (#hudOptions % #axes % each % _2 % #ticks % #gtick %? _1 % #size) 0.02 & over (#charts % charts' % each % #chartData) (scaleChartData 0.001)
display co
#+end_src

#+RESULTS:

* chart-svg-dev: styleBox' versus styleBoxN' versus projectChartTree

- [ ] Use styleBox' or projectChartTree?
- [ ] exact reversal
- [ ] jal does not converge

#+begin_src haskell :results output
view styleBox' ct
#+end_src

#+RESULTS:
: Just Rect -6.0e-4 0.21659999999999996 2.5899999999999996e-2 0.1591

#+begin_src haskell :results output
aspect 2
#+end_src

#+RESULTS:
: Rect -1.0 1.0 -0.5 0.5

single application of styleBox projections

#+begin_src haskell :results output
ct1 = set styleBox' (Just $ aspect 2) ct
view styleBox' ct1
ctn = set (styleBoxN' 10) (Just $ aspect 2) ct
view styleBox' ctn
#+end_src

#+RESULTS:
: Just Rect -6.0e-4 0.21659999999999996 2.5899999999999996e-2 0.1591
: Just Rect -6.0e-4 0.21659999999999996 2.5899999999999996e-2 0.1591

#+begin_src haskell :results output
ct' = projectChartTree (aspect 2) ct
view styleBox' ct'
#+end_src

#+RESULTS:
: Just Rect -1.0359530801519752 0.8429217253210086 -0.566022987491008 0.6144389040994819

#+begin_src haskell :results output
ct' = foldr ($) ct (replicate 10 (projectChartTree (aspect 2)))
view styleBox' ct'
#+end_src

#+RESULTS:
: Just Rect -0.9954771728174939 0.7898170527447951 -0.5346342740252994 0.5856292496911748

* text chart scaling

  #+begin_src haskell :results output
exampleText <- fmap T.pack <$> replicateM 1 (unwords <$> replicateM 3 word)
exampleText
  #+end_src

#+RESULTS:
: ["accusamus et pariatur"]

**** text scaling example

#+begin_src haskell :results output
exampleText <- fmap T.pack <$> replicateM 2 (unwords <$> replicateM 3 word)
-- exampleText = ["illo vitae eius"]
tsNoScale = defaultTextStyle & set #frame (Just $ defaultRectStyle) & set #anchor AnchorStart & set #scaleP NoScaleP
tsScale = defaultTextStyle & set #frame (Just $ defaultRectStyle) & set #anchor AnchorStart & set #scaleP ScalePArea

textNoScale = zipWith (\t x -> TextChart tsNoScale [(t, Point 0 x)]) exampleText [0..]
textScale = zipWith (\t x -> TextChart tsScale [(t, Point 0 (x+0.2))]) exampleText [0..]
points = Chart defaultGlyphStyle $ GlyphData ((CircleGlyph,) <$> (Point 0 0 :corners4 (Rect 0 1 (-0.5) 0.5)))
cs = textScale <> [points]
ct = unnamed cs
co = mempty & #charts .~ ct & #markupOptions % #chartAspect .~ FixedAspect 2 :: ChartOptions
display co
#+end_src

#+RESULTS:

**** singular version "jal"

#+begin_src haskell :results output
-- exampleText <- fmap T.pack <$> replicateM 1 (unwords <$> replicateM 1 word)
exampleText = ["jal"]
tsNoScale = defaultTextStyle & set #frame (Just $ defaultRectStyle) & set #anchor AnchorStart & set #scaleP NoScaleP
tsScale = defaultTextStyle & set #frame (Just $ defaultRectStyle) & set #anchor AnchorStart & set #scaleP ScalePArea

textNoScale = zipWith (\t x -> TextChart tsNoScale [(t, Point 0 (x/4))]) exampleText [0..]
textScale = zipWith (\t x -> TextChart tsScale [(t, Point 0 ((x+0.25)/4))]) exampleText [0..]
points = Chart defaultGlyphStyle $ GlyphData ((CircleGlyph,) <$> (Point 0 0 :corners4 (Rect 0 1 0 1)))
cs = textScale
ct = unnamed cs
co = mempty & #charts .~ ct & #markupOptions % #chartAspect .~ FixedAspect 1 :: ChartOptions
display co
#+end_src

#+RESULTS:

#+begin_src haskell :results output
rOld = fromMaybe one $ view styleBox' ct
sratio = scaleRatio ScalePArea (aspect 2) rOld
sratio
#+end_src

#+RESULTS:
: 8.314439450982071

#+begin_src haskell :results output
rOld
#+end_src

#+RESULTS:
: Rect -6.0e-4 0.21659999999999996 2.5899999999999996e-2 0.1591

**** Unscaled

#+begin_src haskell :results output
coUnscaled = co & #markupOptions % #chartAspect .~ UnscaledAspect
display coUnscaled
#+end_src

#+RESULTS:
: True

**** scaling decomposition

font

#+begin_src haskell :results output
toListOf (charts' % each % #style % #size) ct
#+end_src

#+RESULTS:
: [0.12,0.12,3.0e-2]

scalePArea

#+begin_src haskell :results output
area' (Rect x z y w) = (z-x)*(w-y)
ratioArea r r' = (area' r) / (area' r')
#+end_src

#+RESULTS:

#+begin_src haskell :results output
ratio' = sqrt $ ratioArea (aspect 2) (fromMaybe one $ view styleBox' ct)
ratio'
0.12 * ratio'
#+end_src

#+RESULTS:
: 1.1527102580008153
: 0.13832523096009783



#+begin_src haskell :results output
toListOf (charts' % each) ct & fmap sbox
#+end_src

#+RESULTS:
: [Just Rect -6.0e-4 1.4405999999999999 0.16340000000000002 0.29660000000000003,Just Rect -6.0e-4 1.4405999999999999 -3.660000000000001e-2 9.66e-2,Just Rect -1.65e-2 1.0165 -0.5165 0.5165]


Length of text @ 0.12 size

#+begin_src haskell :results output
fromIntegral (T.length $ head exampleText) * 0.55 * 0.12 + 0.5 * 0.01 * 0.12
#+end_src

#+RESULTS:
: 1.3205999999999998

#+begin_src haskell :results output
view (#style % #borderSize) <$> cs
#+end_src

#+RESULTS:
: [1.0e-2,1.0e-2,3.0e-3]


mempty results

runHud [] should lead to the same charts:

#+begin_src haskell :results output
foldOf charts' (mergeHudChart (runHud [] ct)) == foldOf charts' ct
#+end_src

#+RESULTS:
: True

* legend guff

#+begin_src haskell :results output
display $ x1 & #charts .~ unnamed [blankChart1 one] & #hudOptions .~ (mempty & #legends .~ (view (#hudOptions % #legends) x1 & fmap (second (set (#textStyle % #frame %? #size) 0.1))))
#+end_src

#+RESULTS:
: True

#+begin_src haskell :results output
view (#hudOptions % #legends) x1
#+end_src

#+RESULTS:
: [(Priority {priority = 12.0},LegendOptions {size = 0.3, buffer = 0.1, vgap = 0.2, hgap = 0.1, textStyle = Style {size = 0.2, borderSize = 1.0e-2, color = Colour 0.05 0.05 0.05 1.00, borderColor = Colour 0.02 0.29 0.48 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Just (Style {size = 0.1, borderSize = 1.0e-2, color = Colour 0.02 0.73 0.80 0.10, borderColor = Colour 0.02 0.29 0.48 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Nothing, linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}), linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}, innerPad = 0.1, outerPad = 2.0e-2, frame = Just (Style {size = 0.1, borderSize = 1.0e-2, color = Colour 0.99 0.99 0.99 1.00, borderColor = Colour 0.05 0.05 0.05 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Nothing, linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}), place = PlaceAbsolute Point 0.3 -0.35, overallScale = 0.25, legendCharts = [("palette1 0",[Chart {style = Style {size = 1.5e-2, borderSize = 1.0e-2, color = Colour 0.02 0.73 0.80 1.00, borderColor = Colour 0.02 0.29 0.48 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Nothing, linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}, chartData = LineData [[Point 0.0 1.0,Point 1.0 1.0,Point 2.0 5.0]]}]),("palette1 1",[Chart {style = Style {size = 1.5e-2, borderSize = 1.0e-2, color = Colour 0.02 0.29 0.48 1.00, borderColor = Colour 0.02 0.29 0.48 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Nothing, linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}, chartData = LineData [[Point 0.0 0.0,Point 2.8 3.0]]}]),("palette1 2",[Chart {style = Style {size = 1.5e-2, borderSize = 1.0e-2, color = Colour 0.66 0.07 0.55 1.00, borderColor = Colour 0.02 0.29 0.48 1.00, scaleP = ScalePArea, anchor = AnchorMiddle, rotation = Nothing, translate = Nothing, escapeText = EscapeText, frame = Nothing, linecap = Nothing, linejoin = Nothing, dasharray = Nothing, dashoffset = Nothing, hsize = 0.45, vsize = 1.1, vshift = -0.25, shape = SquareGlyph}, chartData = LineData [[Point 0.5 4.0,Point 0.5 0.0]]}])]})]


#+begin_src haskell :results output
display $ textExample & over (#charts % charts') (fmap (set (#style % #frame) (Just defaultRectStyle))) & over (#charts % charts') (fmap (over (#chartData % textData') (fmap (take 12))))
#+end_src

#+RESULTS:
: True

#+begin_src haskell :results output
:t styleBoxText
textExample & foldOf (#charts % charts') & head & set #chartData (TextData [("a", Point 0 0)]) & set (#style % #frame) (Just defaultRectStyle) & markupChart
#+end_src

#+RESULTS:
: styleBoxText :: Style -
: Text -
: Point Double -
: Rect Double
: Markup {elements = [Node {rootLabel = OpenTag StartTag "g" [Attr {attrName = "stroke-width", attrValue = "0.0"},Attr {attrName = "stroke", attrValue = "none"},Attr {attrName = "fill", attrValue = "rgb(5%, 5%, 5%)"},Attr {attrName = "fill-opacity", attrValue = "1.0"},Attr {attrName = "font-size", attrValue = "0.25"},Attr {attrName = "text-anchor", attrValue = "middle"}], subForest = [Node {rootLabel = OpenTag StartTag "g" [Attr {attrName = "stroke-width", attrValue = "0.0025"},Attr {attrName = "stroke", attrValue = "rgb(2%, 29%, 48%)"},Attr {attrName = "stroke-opacity", attrValue = "1.0"},Attr {attrName = "fill", attrValue = "rgb(2%, 73%, 80%)"},Attr {attrName = "fill-opacity", attrValue = "0.1"}], subForest = [Node {rootLabel = OpenTag EmptyElemTag "rect" [Attr {attrName = "width", attrValue = "0.115"},Attr {attrName = "height", attrValue = "0.2775"},Attr {attrName = "x", attrValue = "-0.0575"},Attr {attrName = "y", attrValue = "-0.1388"}], subForest = []}]},Node {rootLabel = OpenTag StartTag "text" [Attr {attrName = "x", attrValue = "0"},Attr {attrName = "y", attrValue = "0"}], subForest = [Node {rootLabel = Content "a", subForest = []}]}]}]}

#+begin_src haskell :results output
s = textExample & foldOf (#charts % charts') & head & view #style
styleBoxText s "a" (Point 0 0)
view #vsize s * 0.25 * 0.5
#+end_src

#+RESULTS:
: Rect -5.625e-2 5.625e-2 -0.1375 0.1375
: 0.1375

A rectangular chart created to surround text continues to undergo scaling, whilst the text itself does not. This is why markupText includes creation of a rectangualr frame.

#+begin_src haskell :results output
textExample & foldOf (#charts % charts') & fmap (view #chartData >>> (\(TextData xs)-> xs)) & mconcat & fmap (\x -> Chart s (TextData [x])) & unnamed & (\x -> x <> rectangularize defaultRectStyle x) & (\x -> textExample & set #charts x :: ChartOptions) & set (#markupOptions % #chartAspect) (FixedAspect 2) & display
#+end_src

#+RESULTS:
#+begin_example
<interactive>:173:71: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘ChartData’ not matched:
            RectData _
            LineData _
            GlyphData _
            PathData _
            ...
True
#+end_example

* style unification

similar to https://hackage.haskell.org/package/reanimate-svg-0.9.3.1/docs/Graphics-SvgTree-Types.html#v:drawAttributes

old styles

#+begin_src haskell :results output
data RectStyle = RectStyle
  { borderSize :: Double,
    borderColor :: Colour,
    color :: Colour,
    scaleRect :: ScaleP
  }
data TextStyle = TextStyle
  { size :: Double,
    color :: Colour,
    anchor :: Anchor,
    hsize :: Double,
    vsize :: Double,
    vshift :: Double,
    rotation :: Maybe Double,
    scaleText :: ScaleP,
    escapeText :: EscapeText,
    frame :: Maybe RectStyle
  }
data GlyphStyle = GlyphStyle
  { -- | glyph radius
    size :: Double,
    -- | fill color
    color :: Colour,
    -- | stroke color
    borderColor :: Colour,
    -- | stroke width (adds a bit to the bounding box)
    borderSize :: Double,
    shape :: GlyphShape,
    rotation :: Maybe Double,
    translate :: Maybe (Point Double),
    scaleGlyph :: ScaleP
  }
data LineStyle = LineStyle
  { size :: Double,
    color :: Colour,
    linecap :: Maybe LineCap,
    linejoin :: Maybe LineJoin,
    dasharray :: Maybe [Double],
    dashoffset :: Maybe Double,
    scaleLine :: ScaleP
  }
data PathStyle = PathStyle
  { borderSize :: Double,
    borderColor :: Colour,
    color :: Colour,
    scalePath' :: ScaleP
  }
#+end_src

* chart-svg-dev: addHud refactor

Removed from toHuds

      #+begin_src haskell :results output
      <> [ fromEffect (lastPriority o + 1) $
             applyChartAspect asp
         ]
      #+end_src

removed from runHudWith

    #+begin_src haskell :results output
    & (\x -> group (Just "chart") [view #chart x] <> group (Just "hud") [view #hud x])
    #+end_src

remove initial projection entirely.

          #+begin_src haskell :results output
          (cs & over chart' (projectWith cb (maybe one padSingletons $ view styleBox' cs)))
          #+end_src

removed:

#+begin_src haskell :results output
-- | Apply a ChartAspect
applyChartAspect :: ChartAspect -> State HudChart ()
applyChartAspect fa = do
  hc <- get
  case fa of
    UnscaledAspect -> pure ()
    _ -> modify (set hudBox' (getHudBox fa hc))
#+end_src
